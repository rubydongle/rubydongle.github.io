<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Read Fucking Code"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>页表 | 咚咚！咚咚！</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">页表</h1><a id="logo" href="/.">咚咚！咚咚！</a><p class="description">ruby.dongle</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">页表</h1><div class="post-meta"><a href="/2019/09/04/techdoc/MM/页表/#comments" class="comment-count"></a><p><span class="date">Sep 04, 2019</span><span><a href="/categories/技术文章/" class="category">技术文章</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="物理内存页的划分"><a href="#物理内存页的划分" class="headerlink" title="物理内存页的划分"></a>物理内存页的划分</h2><p>因为MMU以页(page)为单位对物理内存进行处理，所以物理内存被划分为一个个物理页来进行管理。<br>不同体系机构支持页大小不尽相同，有些体系结构甚至支持集中不同的页大小。大多数32位体系结构支持4KB的页，而64位体系结构一般会支持8KB的页。这意味着，在支持4KB页的1GB物理内存机器上，物理页被划分为161244个页。<br>内核中用struct page表示系统中的物理页。<br>include/linux/mm_types.h  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Each physical page in the system has a struct page associated with</span><br><span class="line"> * it to keep track of whatever it is we are using the page for at the</span><br><span class="line"> * moment. Note that we have no way to track which tasks are using</span><br><span class="line"> * a page, though if it is a pagecache page, rmap structures can tell us</span><br><span class="line"> * who is mapping it.</span><br><span class="line"> *</span><br><span class="line"> * The objects in struct page are organized in double word blocks in</span><br><span class="line"> * order to allows us to use atomic double word operations on portions</span><br><span class="line"> * of struct page. That is currently only used by slub but the arrangement</span><br><span class="line"> * allows the use of atomic double word operations on the flags/mapping</span><br><span class="line"> * and lru list pointers also.</span><br><span class="line"> */</span><br><span class="line">struct page &#123;</span><br><span class="line">        /* First double word block */</span><br><span class="line">        unsigned long flags;            /* Atomic flags, some possibly</span><br><span class="line">                                         * updated asynchronously */</span><br><span class="line">        union &#123;</span><br><span class="line">                struct address_space *mapping;  /* If low bit clear, points to</span><br><span class="line">                                                 * inode address_space, or NULL.</span><br><span class="line">                                                 * If page mapped as anonymous</span><br><span class="line">                                                 * memory, low bit is set, and</span><br><span class="line">                                                 * it points to anon_vma object:</span><br><span class="line">                                                 * see PAGE_MAPPING_ANON below.</span><br><span class="line">                                                 */</span><br><span class="line">                void *s_mem;                    /* slab first object */</span><br><span class="line">                atomic_t compound_mapcount;     /* first tail page */</span><br><span class="line">                /* page_deferred_list().next     -- second tail page */</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        /* Second double word */</span><br><span class="line">        union &#123;</span><br><span class="line">                pgoff_t index;          /* Our offset within mapping. */</span><br><span class="line">                void *freelist;         /* sl[aou]b first free object */</span><br><span class="line">                /* page_deferred_list().prev    -- second tail page */</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        union &#123;</span><br><span class="line">#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span><br><span class="line">        defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span><br><span class="line">                /* Used for cmpxchg_double in slub */</span><br><span class="line">                unsigned long counters;</span><br><span class="line">#else</span><br><span class="line">                /*</span><br><span class="line">                 * Keep _refcount separate from slub cmpxchg_double data.</span><br><span class="line">                 * As the rest of the double word is protected by slab_lock</span><br><span class="line">                 * but _refcount is not.</span><br><span class="line">                 */</span><br><span class="line"></span><br><span class="line">                unsigned counters;</span><br><span class="line">#endif</span><br><span class="line">                struct &#123;</span><br><span class="line"></span><br><span class="line">                        union &#123;</span><br><span class="line">                                /*</span><br><span class="line">                                 * Count of ptes mapped in mms, to show when</span><br><span class="line">                                 * page is mapped &amp; limit reverse map searches.</span><br><span class="line">                                 *</span><br><span class="line">                                 * Extra information about page type may be</span><br><span class="line">                                 * stored here for pages that are never mapped,</span><br><span class="line">                                 * in which case the value MUST BE &lt;= -2.</span><br><span class="line">                                 * See page-flags.h for more details.</span><br><span class="line">                                 */</span><br><span class="line">                                atomic_t _mapcount;</span><br><span class="line"></span><br><span class="line">                                unsigned int active;            /* SLAB */</span><br><span class="line">                                struct &#123;                        /* SLUB */</span><br><span class="line">                                        unsigned inuse:16;</span><br><span class="line">                                        unsigned objects:15;</span><br><span class="line">                                        unsigned frozen:1;</span><br><span class="line">                                &#125;;</span><br><span class="line">                                int units;                      /* SLOB */</span><br><span class="line">                        &#125;;</span><br><span class="line">                        /*</span><br><span class="line">                         * Usage count, *USE WRAPPER FUNCTION* when manual</span><br><span class="line">                         * accounting. See page_ref.h</span><br><span class="line">                         */</span><br><span class="line">                        atomic_t _refcount;</span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Third double word block</span><br><span class="line">         *</span><br><span class="line">         * WARNING: bit 0 of the first word encode PageTail(). That means</span><br><span class="line">         * the rest users of the storage space MUST NOT use the bit to</span><br><span class="line">         * avoid collision and false-positive PageTail().</span><br><span class="line">         */</span><br><span class="line">        union &#123;</span><br><span class="line">                struct list_head lru;   /* Pageout list, eg. active_list</span><br><span class="line">                                         * protected by zone_lru_lock !</span><br><span class="line">                                         * Can be used as a generic list</span><br><span class="line">                                         * by the page owner.</span><br><span class="line">                                         */</span><br><span class="line">                struct dev_pagemap *pgmap; /* ZONE_DEVICE pages are never on an</span><br><span class="line">                                            * lru or handled by a slab</span><br><span class="line">                                            * allocator, this points to the</span><br><span class="line">                                            * hosting device page map.</span><br><span class="line">                                            */</span><br><span class="line">                struct &#123;                /* slub per cpu partial pages */</span><br><span class="line">                        struct page *next;      /* Next partial slab */</span><br><span class="line">#ifdef CONFIG_64BIT</span><br><span class="line">                        int pages;      /* Nr of partial slabs left */</span><br><span class="line">                        int pobjects;   /* Approximate # of objects */</span><br><span class="line">#else</span><br><span class="line">                        short int pages;</span><br><span class="line">                        short int pobjects;</span><br><span class="line">#endif</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                struct rcu_head rcu_head;       /* Used by SLAB</span><br><span class="line">                                                 * when destroying via RCU</span><br><span class="line">                                                 */</span><br><span class="line">                /* Tail pages of compound page */</span><br><span class="line">                struct &#123;</span><br><span class="line">                        unsigned long compound_head; /* If bit zero is set */</span><br><span class="line"></span><br><span class="line">                        /* First tail page only */</span><br><span class="line">#ifdef CONFIG_64BIT</span><br><span class="line">                        /*</span><br><span class="line">                         * On 64 bit system we have enough space in struct page</span><br><span class="line">                         * to encode compound_dtor and compound_order with</span><br><span class="line">                         * unsigned int. It can help compiler generate better or</span><br><span class="line">                         * smaller code on some archtectures.</span><br><span class="line">                         */</span><br><span class="line">                        unsigned int compound_dtor;</span><br><span class="line">                        unsigned int compound_order;</span><br><span class="line">#else</span><br><span class="line">                        unsigned short int compound_dtor;</span><br><span class="line">                        unsigned short int compound_order;</span><br><span class="line">#endif</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; USE_SPLIT_PMD_PTLOCKS</span><br><span class="line">                struct &#123;</span><br><span class="line">                        unsigned long __pad;    /* do not overlay pmd_huge_pte</span><br><span class="line">                                                 * with compound_head to avoid</span><br><span class="line">                                                 * possible bit 0 collision.</span><br><span class="line">                                                 */</span><br><span class="line">                        pgtable_t pmd_huge_pte; /* protected by page-&gt;ptl */</span><br><span class="line">                &#125;;</span><br><span class="line">#endif</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        /* Remainder is not double word aligned */</span><br><span class="line">        union &#123;</span><br><span class="line">                unsigned long private;          /* Mapping-private opaque data:</span><br><span class="line">                                                 * usually used for buffer_heads</span><br><span class="line">                                                 * if PagePrivate set; used for</span><br><span class="line">                                                 * swp_entry_t if PageSwapCache;</span><br><span class="line">                                                 * indicates order in the buddy</span><br><span class="line">                                                 * system if PG_buddy is set.</span><br><span class="line">                                                 */</span><br><span class="line">#if USE_SPLIT_PTE_PTLOCKS</span><br><span class="line">#if ALLOC_SPLIT_PTLOCKS</span><br><span class="line">                spinlock_t *ptl;</span><br><span class="line">#else</span><br><span class="line">                spinlock_t ptl;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">                struct kmem_cache *slab_cache;  /* SL[AU]B: Pointer to slab */</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MEMCG</span><br><span class="line">        struct mem_cgroup *mem_cgroup;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * On machines where all RAM is mapped into kernel address space,</span><br><span class="line">         * we can simply calculate the virtual address. On machines with</span><br><span class="line">         * highmem some memory is mapped into kernel virtual memory</span><br><span class="line">         * dynamically, so we need a place to store that address.</span><br><span class="line">         * Note that this field could be 16 bits on x86 ... ;)</span><br><span class="line">         *</span><br><span class="line">         * Architectures with slow multiplication can define</span><br><span class="line">         * WANT_PAGE_VIRTUAL in asm/page.h</span><br><span class="line">         */</span><br><span class="line">#if defined(WANT_PAGE_VIRTUAL)</span><br><span class="line">        void *virtual;                  /* Kernel virtual address (NULL if</span><br><span class="line">                                           not kmapped, ie. highmem) */</span><br><span class="line">#endif /* WANT_PAGE_VIRTUAL */</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_KMEMCHECK</span><br><span class="line">        /*</span><br><span class="line">         * kmemcheck wants to track the status of each byte in a page; this</span><br><span class="line">         * is a pointer to such a status block. NULL if not tracked.</span><br><span class="line">         */</span><br><span class="line">        void *shadow;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef LAST_CPUPID_NOT_IN_PAGE_FLAGS</span><br><span class="line">        int _last_cpupid;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化结构：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct page &#123;</span><br><span class="line">    unsigned long		flags;</span><br><span class="line">    atomic_t			_count;</span><br><span class="line">    atomic_t			_mapcount;</span><br><span class="line">    unsigned long 		private;</span><br><span class="line">    struct address_space	*mapping;</span><br><span class="line">    pgoff_t			index;</span><br><span class="line">    struct list_head		lru;</span><br><span class="line">    void			*virtual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-页表"><a href="#2-页表" class="headerlink" title="2.页表"></a>2.页表</h2><p><a href="https://blog.csdn.net/yrj/article/details/2508785" target="_blank" rel="noopener">https://blog.csdn.net/yrj/article/details/2508785</a><br>Linux内核软件架构习惯被分成硬件相关层和硬件无关层。对于页表管理，2.6.10以前（包括2.6.10）在硬件无关层使用了3级页表目录管理的方式，它不管底层硬件是否实现的也是3级的页表管理：  </p>
<ul>
<li>Page Global Directory (PGD)</li>
<li>Page Middle Directory (PMD)</li>
<li>Page Table (PTE)</li>
</ul>
<p>从2.6.11开始，为了配合64位CPU的体系结构，硬件无关层则使用了4级页表目录管理的方式：  </p>
<ul>
<li>Page Global Directory (PGD)</li>
<li>Page Upper Directory (PUD)</li>
<li>Page Middle Directory (PMD)</li>
<li>Page Table (PTE)</li>
</ul>
<p>PGD每个条目中指向一个PUD，PUD的每个条目指向一个PMD，PMD的每个条目指向一个PTE，PTE的每个条目指向一个页面(Page)的物理首地址。因此一个线性地址被分为了5个部分，如下图：<br><img src="/images/mm/PGT.JPG" alt="img"></p>
<p>PGD，PUD，PMD，PTE中到底有几个条目，不同的CPU体系结构有不同的定义。<br>虽然硬件无关层是这么设计的，但是底层硬件未必也是这样实现的。如x86体系结构，如果不使用PAE（Physical Address Extension)特性，则硬件底层实现的是2级的页表目录管理，事实上，只有PGD，PTE才是真正有意义的。</p>
<ul>
<li><p>页目录（Page directory）<br>  每个进程所代表的上下文数据结构中都有一个指针（mm_struct-&gt;pgd），其指向这个进程所使用的PGD的一个页（page frame）。<br>  这个页面中包含了一个类型为pgd_t的数组。pgd的载入到CPU的方式完全和体系结构相关。<br>  x86，进程的页表地址从mm_struct-&gt;pgd载入到CR3寄存器，载入页表地址的同时，会引起TLB（快表，是对页目录，页表缓存的缓冲区）也被强制刷新。事实上，这也是__flush_tlb()函数，实现的机制。</p>
<p>  PGD中的每个条目指向一个页（page frame）， 这个页是“由类型为pud_t的条目组成的PUD”。<br>  PUD中的每个条目同样指向一个页，这个页是“由类型为pmd_t的条目组成的PMD”。<br>  PMD的每个条目指向一个页，这个页是“由类型为pte_t的条目组成的PTE”。<br>  PTE的每个条目就指向了真正的数据或指令所在的页面的首地址的了，这也不是100%的，如果所需要的页面被交换到磁盘空间去后，这个条目就包含的内容是在当page fault发生后，传入需要调用的 do_swap_page()函数，找到包含页面数据的交换空间。</p>
<p>  将线性地址转换成物理地址，需要将线性地址分成5个部分，其中4个的值是在各级页表中的索引或者也可以看成是偏移(OFFSET)，另外一个是数据在页中的偏移。<br>  为了分别析出这5个部分，各级页表和页中偏移都拥有特定的几个宏：SHIFT，SIZE和MASK。SHIFT宏表示各级页表或页中偏移所占用的bit数。</p>
<p>  MASK的值和线性地址做AND运算，获得一个各级的高位部分，一般用于页面，页表对齐。SIZE宏表示各级所能管理的内存空间的字节数。<br>  <img src="/images/mm/LinearAddressBitSizeMacros.JPG" alt="img"><br>  MASK和SIZE都是有SHIFT计算得到，如x86体系结构是这样的：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define PAGE_SHIFT??? 12</span><br><span class="line">#define PAGE_SIZE??? (1UL &lt;&lt; PAGE_SHIFT)</span><br><span class="line">#define PAGE_MASK?? (~ (PAGE_SIZE - 1))</span><br></pre></td></tr></table></figure>

<p>  PAGE_SHIFT是线性地址中偏移(offset)的位的位数，x86系统是12位。page的字节数计算很简单：2PAGE_SHIFT （和1&lt;&lt;PAGE_SHIFT是同样的结果）。如果需要对一个地址做页边界的对齐，则使用PAGE_ALIGN()宏，这个宏将地址加上PAGE_SIZE-1再和PAGE_MASK做AND操作即可。事实上PAGE_ALIGN()宏是和下一个页的边界对齐的。<br>  PMD_SHIFT是线性地址中第三级页表的所占的位数，PMD_SIZE和PMD_MARK是由这个宏计算得到的。<br>  PUD_SHIFT是线性地址中第二级页表的所占的位数，PUD_SIZE和PUD_MARK是由这个宏计算得到的。<br>  PGD_SHIFT是线性地址中第一级页表的所占的位数，PGD_SIZE和PGD_MARK是由这个宏计算得到的。<br>  <img src="/images/mm/LinearAddressSizeAndMaskMacros.JPG" alt="img"><br>  最后介绍4个重要的宏：PTRS_PER_PGD,PTRS_PER_PUD, PTRS_PER_PMD,PTRS_PER_PTE。它们用于确定每级页表有多少条目。<br>  不使能PAE特性的x86体系结构这几个宏定义如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define PTRS_PER_PGD? 1024</span><br><span class="line">#define PTRS_PER_PUD??? 1? //这种情况下PUD事实不起作用，为了代码的硬件无关性，设置为1。</span><br><span class="line"></span><br><span class="line">//在include/asm-generic/pgtable-nopud.h中定义</span><br><span class="line">#define PTRS_PER_PMD? 1? //这种情况下PMD事实不起作用，为了代码的硬件无关性，设置为1。</span><br><span class="line"></span><br><span class="line">//在include/asm-generic/pgtable-nopmd.h中定义</span><br><span class="line"></span><br><span class="line">#define PTRS_PER_PTE? 1024</span><br></pre></td></tr></table></figure>
</li>
<li><p>页表条目(Page table entry)<br>  页表的每个条目都是一个声明为数据结构的对象：pgd_t,pud_t,pmd_t和pte_t分别对应PGD,PUD,PMD和PTE。<br>  虽然这些数据结构常常只有一个无符号整数，它们被定义成数据结构有2个原因：第一，类型保护，防止被不合适的方式使用。第二，容易扩展每个条目所占字节的数量，如x86使能PAE，则需要另外加入4位(原书是说4位,但是我觉得应该是错误的，应该是加入了4个字节），以使得能够访问多余4GB的物理内存。<br>  为了保持一些保护位，定义了pgprot_t数据结构，它保存相关的标志，通常会保持在页表条目的低位区域。</p>
<p>  为了类型的计算，在文件asm/page_32.h或者asm/page_64.h中定义了5个宏。传入上述的类型，返回相应的数据结构中的部分数值：pte_val(),pmd_val(),pud_val()和pgprot_val(). 相反的操作的计算的宏：<strong>pte(),</strong>pmd(),<strong>pud(),</strong>pgd()和__pgprot()。</p>
<p>  条目中的状态位，完全是和体系结构相关的。下面解释一下不使能PAE的x86体系结构下，各个状态位的含义。<br>  没有使能PAE的x86，pte_t数据结构中只有一个32位的整数。每个PTE中的类型为pte_t的指针指向一个页面的首地址，也就是说指向的地址总是页面对齐的。因此，在这个整数中PAGE_SHIFT指定数目的位数，也就是12位，是给页表条目中的状态位。列表如下：<br>  <img src="/images/mm/PTEProtectionAndStatusBits.JPG" alt="img"><br>  比较费解的是_PAGE_PROTNONE这个状态位，x86的体系结构上并不存在这个状态位，LINUX内核借用了PAT位作为这个来使用。<br>  这里还有一个问题如果有PSE位被设置，则PAT位的位置就会使用另外一个位置，幸运的是，LINUX内核不会在用户页面中使用PSE特性。<br>  LINUX内核挪用这个位的目的是：确定一个虚拟内存的页面在物理内存中是存在的，但是用户空间的进程不能访问它，如同对一段内存区域调用mprotect() API函数并传入PROT_NONE标志一样。当一段内存区域被要求保护，_PAGE_PRESENT为被清除，_PAGE_PROTNONE位被置一。<br>  pte_present()宏会同时检测这2位的设置情况，让kernel能够自己知道对应的PTE是否可用：<br>  #define pte_present(x)? ((x).pte_low &amp; (_PAGE_PRESENT | _PAGE_PROTNONE))</p>
<p>  如果正好是用户空间不能访问的页面，这就相当巧妙了，但是也相当的重要考量。因为硬件状态为_PAGE_PRESENT已经被清除，当试图访问这个页面的时候，会产生一个page fault的异常，LINUX内核强制的保护了页面访问，但是内核还是知道页面是存在的，如果需要交换到磁盘或者进程退出释放页面，能够做出正确的动作。</p>
</li>
</ul>
<p><a href="https://my.oschina.net/victorlovecode/blog/344394" target="_blank" rel="noopener">ARMv8(aarch64)页表建立过程详细分析</a><br>通过配置CONFIG_ARM64_PTDUMP=y后我们可以通过/sys/kernel/debug/kernel_page_tables查看页表情况。<br><a href="/files/mm/kernel_page_tables.txt">kernel_page_tables</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">---[ Modules start ]---</span><br><span class="line">---[ Modules end ]---</span><br><span class="line">---[ vmalloc() Area ]---</span><br><span class="line">0xffffff8008000000-0xffffff8008010000          64K PTE       RW NX SHD AF NG         UXN DEVICE/nGnRE</span><br><span class="line">0xffffff8008011000-0xffffff8008012000           4K PTE       RW NX SHD AF NG         UXN DEVICE/nGnRE</span><br><span class="line">0xffffff8008013000-0xffffff8008014000           4K PTE       RW NX SHD AF NG         UXN DEVICE/nGnRE</span><br><span class="line">0xffffff8008015000-0xffffff8008016000           4K PTE       RW NX SHD AF NG         UXN DEVICE/nGnRE</span><br><span class="line">0xffffff8008017000-0xffffff800801a000          12K PTE       RW NX SHD AF NG         UXN MEM/NORMAL</span><br><span class="line">0xffffff800801b000-0xffffff800801e000          12K PTE       RW NX SHD AF NG         UXN MEM/NORMAL</span><br><span class="line">0xffffff800801f000-0xffffff8008022000          12K PTE       RW NX SHD AF NG         UXN MEM/NORMAL</span><br><span class="line">0xffffff8008023000-0xffffff8008026000          12K PTE       RW NX SHD AF NG         UXN MEM/NORMAL</span><br><span class="line">0xffffff8008027000-0xffffff800802a000          12K PTE       RW NX SHD AF NG         UXN MEM/NORMAL</span><br><span class="line">0xffffff800802b000-0xffffff800802e000          12K PTE       RW NX SHD AF NG         UXN MEM/NORMAL</span><br><span class="line">0xffffff800802f000-0xffffff8008032000          12K PTE       RW NX SHD AF NG         UXN MEM/NORMAL</span><br><span class="line">0xffffff8008033000-0xffffff8008036000          12K PTE       RW NX SHD AF NG         UXN MEM/NORMAL</span><br><span class="line">0xffffff8008037000-0xffffff8008038000           4K PTE       ro NX SHD AF NG         UXN MEM/NORMAL</span><br><span class="line">0xffffff8008039000-0xffffff8008079000         256K PTE       RW NX SHD AF NG         UXN MEM/NORMAL-NC</span><br><span class="line">0xffffff800807a000-0xffffff800807b000           4K PTE       RW NX SHD AF NG         UXN DEVICE/nGnRE</span><br><span class="line">0xffffff800807e000-0xffffff800807f000           4K PTE       RW NX SHD AF NG         UXN DEVICE/nGnRE</span><br><span class="line">0xffffff8008080000-0xffffff8008086000          24K PTE       RW NX SHD AF NG         UXN DEVICE/nGnRE</span><br><span class="line">0xffffff8008088000-0xffffff800808e000          24K PTE       RW NX SHD AF NG         UXN DEVICE/nGnRE</span><br><span class="line">0xffffff800808f000-0xffffff8008090000           4K PTE       RW NX SHD AF NG         UXN DEVICE/nGnRE</span><br><span class="line">0xffffff8008091000-0xffffff8008092000           4K PTE       RW NX SHD AF NG         UXN DEVICE/nGnRE</span><br><span class="line">0xffffff8008093000-0xffffff8008094000           4K PTE       RW NX SHD AF NG         UXN DEVICE/nGnRE</span><br><span class="line">0xffffff8008095000-0xffffff80080a6000          68K PTE       RW NX SHD AF NG         UXN MEM/NORMAL-NC</span><br><span class="line">......</span><br><span class="line">0xffffff800d3f9000-0xffffff800d3fc000          12K PTE       RW NX SHD AF NG         UXN MEM/NORMAL-NC</span><br><span class="line">0xffffff800d400000-0xffffff800d600000           2M PMD       RW NX SHD AF NG     BLK UXN DEVICE/nGnRE</span><br><span class="line">0xffffff800d601000-0xffffff800d60b000          40K PTE       RW NX SHD AF NG         UXN MEM/NORMAL-NC</span><br><span class="line">......</span><br><span class="line">0xffffffbebff30000-0xffffffbebfff0000         768K PTE       RW NX SHD AF NG         UXN MEM/NORMAL</span><br><span class="line">---[ vmalloc() End ]---</span><br><span class="line">---[ Fixmap start ]---</span><br><span class="line">0xffffffbefe7fc000-0xffffffbefe7fd000           4K PTE       ro x  SHD AF            UXN MEM/NORMAL</span><br><span class="line">0xffffffbefe7fd000-0xffffffbefe7fe000           4K PTE       ro NX SHD AF NG         UXN MEM/NORMAL</span><br><span class="line">0xffffffbefe800000-0xffffffbefea00000           2M PMD       ro NX SHD AF NG     BLK UXN MEM/NORMAL</span><br><span class="line">---[ Fixmap end ]---</span><br><span class="line">---[ PCI I/O start ]---</span><br><span class="line">---[ PCI I/O end ]---</span><br><span class="line">---[ vmemmap start ]---</span><br><span class="line">0xffffffbfed000000-0xffffffbff5000000         128M PMD       RW NX SHD AF NG     BLK UXN MEM/NORMAL</span><br><span class="line">---[ vmemmap end ]---</span><br><span class="line">---[ Linear Mapping ]---</span><br><span class="line">0xfffffffb40000000-0xfffffffb40080000         512K PTE F     RW NX SHD AF            UXN MEM/NORMAL</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h2 id="3-区"><a href="#3-区" class="headerlink" title="3.区"></a>3.区</h2><p>区通过struct zone表示<br>include/linux/mmzone.h  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">struct zone &#123;</span><br><span class="line">        /* Read-mostly fields */</span><br><span class="line"></span><br><span class="line">        /* zone watermarks, access with *_wmark_pages(zone) macros */</span><br><span class="line">        unsigned long watermark[NR_WMARK];</span><br><span class="line"></span><br><span class="line">        unsigned long nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * We don&apos;t know if the memory that we&apos;re going to allocate will be</span><br><span class="line">         * freeable or/and it will be released eventually, so to avoid totally</span><br><span class="line">         * wasting several GB of ram we must reserve some of the lower zone</span><br><span class="line">         * memory (otherwise we risk to run OOM on the lower zones despite</span><br><span class="line">         * there being tons of freeable ram on the higher zones).  This array is</span><br><span class="line">         * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl</span><br><span class="line">         * changes.</span><br><span class="line">         */</span><br><span class="line">        long lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_NUMA</span><br><span class="line">        int node;</span><br><span class="line">#endif</span><br><span class="line">        struct pglist_data      *zone_pgdat;</span><br><span class="line">        struct per_cpu_pageset __percpu *pageset;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_CMA</span><br><span class="line">        bool                    cma_alloc;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef CONFIG_SPARSEMEM</span><br><span class="line">        /*</span><br><span class="line">         * Flags for a pageblock_nr_pages block. See pageblock-flags.h.</span><br><span class="line">         * In SPARSEMEM, this map is stored in struct mem_section</span><br><span class="line">         */</span><br><span class="line">        unsigned long           *pageblock_flags;</span><br><span class="line">#endif /* CONFIG_SPARSEMEM */</span><br><span class="line"></span><br><span class="line">        /* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span><br><span class="line">        unsigned long           zone_start_pfn;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * spanned_pages is the total pages spanned by the zone, including</span><br><span class="line">         * holes, which is calculated as:</span><br><span class="line">         *      spanned_pages = zone_end_pfn - zone_start_pfn;</span><br><span class="line">         *</span><br><span class="line">         * present_pages is physical pages existing within the zone, which</span><br><span class="line">         * is calculated as:</span><br><span class="line">         *      present_pages = spanned_pages - absent_pages(pages in holes);</span><br><span class="line">         *</span><br><span class="line">         * managed_pages is present pages managed by the buddy system, which</span><br><span class="line">         * is calculated as (reserved_pages includes pages allocated by the</span><br><span class="line">         * bootmem allocator):</span><br><span class="line">         *      managed_pages = present_pages - reserved_pages;</span><br><span class="line">         *</span><br><span class="line">         * So present_pages may be used by memory hotplug or memory power</span><br><span class="line">         * management logic to figure out unmanaged pages by checking</span><br><span class="line">         * (present_pages - managed_pages). And managed_pages should be used</span><br><span class="line">         * by page allocator and vm scanner to calculate all kinds of watermarks</span><br><span class="line">         * and thresholds.</span><br><span class="line">         *</span><br><span class="line">         * Locking rules:</span><br><span class="line">         *</span><br><span class="line">         * zone_start_pfn and spanned_pages are protected by span_seqlock.</span><br><span class="line">         * It is a seqlock because it has to be read outside of zone-&gt;lock,</span><br><span class="line">         * and it is done in the main allocator path.  But, it is written</span><br><span class="line">         * quite infrequently.</span><br><span class="line">         *</span><br><span class="line">         * The span_seq lock is declared along with zone-&gt;lock because it is</span><br><span class="line">         * frequently read in proximity to zone-&gt;lock.  It&apos;s good to</span><br><span class="line">         * give them a chance of being in the same cacheline.</span><br><span class="line">         *</span><br><span class="line">         * Write access to present_pages at runtime should be protected by</span><br><span class="line">         * mem_hotplug_begin/end(). Any reader who can&apos;t tolerant drift of</span><br><span class="line">         * present_pages should get_online_mems() to get a stable value.</span><br><span class="line">         *</span><br><span class="line">         * Read access to managed_pages should be safe because it&apos;s unsigned</span><br><span class="line">         * long. Write access to zone-&gt;managed_pages and totalram_pages are</span><br><span class="line">         * protected by managed_page_count_lock at runtime. Idealy only</span><br><span class="line">         * adjust_managed_page_count() should be used instead of directly</span><br><span class="line">         * touching zone-&gt;managed_pages and totalram_pages.</span><br><span class="line">         */</span><br><span class="line">        unsigned long           managed_pages;</span><br><span class="line">        unsigned long           spanned_pages;</span><br><span class="line">        unsigned long           present_pages;</span><br><span class="line"></span><br><span class="line">        const char              *name;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_RSC_MEM_DEFRAG</span><br><span class="line">        unsigned long   nr_migrate_unmovable_isolate_sord_block;</span><br><span class="line">        unsigned long   nr_migrate_unmovable_isolate_bord_block;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MEMORY_ISOLATION</span><br><span class="line">        /*</span><br><span class="line">         * Number of isolated pageblock. It is used to solve incorrect</span><br><span class="line">         * freepage counting problem due to racy retrieving migratetype</span><br><span class="line">         * of pageblock. Protected by zone-&gt;lock.</span><br><span class="line">         */</span><br><span class="line">        unsigned long           nr_isolate_pageblock;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MEMORY_HOTPLUG</span><br><span class="line">        /* see spanned/present_pages for more description */</span><br><span class="line">        seqlock_t               span_seqlock;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        int initialized;</span><br><span class="line"></span><br><span class="line">        /* Write-intensive fields used from the page allocator */</span><br><span class="line">        ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line">        /* free areas of different sizes */</span><br><span class="line">        struct free_area        free_area[MAX_ORDER];</span><br><span class="line"></span><br><span class="line">        /* zone flags, see below */</span><br><span class="line">        unsigned long           flags;</span><br><span class="line"></span><br><span class="line">        /* Primarily protects free_area */</span><br><span class="line">        spinlock_t              lock;</span><br><span class="line"></span><br><span class="line">        /* Write-intensive fields used by compaction and vmstats. */</span><br><span class="line">        ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * When free pages are below this point, additional steps are taken</span><br><span class="line">         * when reading the number of free pages to avoid per-cpu counter</span><br><span class="line">         * drift allowing watermarks to be breached</span><br><span class="line">         */</span><br><span class="line">        unsigned long percpu_drift_mark;</span><br><span class="line"></span><br><span class="line">#if defined CONFIG_COMPACTION || defined CONFIG_CMA</span><br><span class="line">        /* pfn where compaction free scanner should start */</span><br><span class="line">        unsigned long           compact_cached_free_pfn;</span><br><span class="line">        /* pfn where async and sync compaction migration scanner should start */</span><br><span class="line">        unsigned long           compact_cached_migrate_pfn[2];</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_COMPACTION</span><br><span class="line">        /*</span><br><span class="line">         * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span><br><span class="line">         * are skipped before trying again. The number attempted since</span><br><span class="line">         * last failure is tracked with compact_considered.</span><br><span class="line">         */</span><br><span class="line">        unsigned int            compact_considered;</span><br><span class="line">        unsigned int            compact_defer_shift;</span><br><span class="line">        int                     compact_order_failed;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined CONFIG_COMPACTION || defined CONFIG_CMA</span><br><span class="line">        /* Set to true when the PG_migrate_skip bits should be cleared */</span><br><span class="line">        bool                    compact_blockskip_flush;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        bool                    contiguous;</span><br><span class="line"></span><br><span class="line">        ZONE_PADDING(_pad3_)</span><br><span class="line">        /* Zone statistics */</span><br><span class="line">        atomic_long_t           vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><blockquote><p>原文作者: 董宇</p><p>原文链接: <a href="https://rubydongle.github.io/2019/09/04/techdoc/MM/页表/">https://rubydongle.github.io/2019/09/04/techdoc/MM/页表/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/Linux/">Linux</a><a href="/tags/内核/">内核</a><a href="/tags/内存/">内存</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/09/04/techdoc/MM/ion/" class="pre">ion内存分配</a><a href="/2019/09/03/techdoc/NES Game/PPU/PPU概述/" class="next">PPU概述</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#物理内存页的划分"><span class="toc-text">物理内存页的划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-页表"><span class="toc-text">2.页表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-区"><span class="toc-text">3.区</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/24/伪终端使用/">伪终端使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/18/安装WordPress/">安装WordPress</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/17/php安装/">php安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/17/mysql安装/">mysql安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/17/nginx安装/">nginx安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/17/服务器搭建/">服务器搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/15/LVM/">LVM</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/15/pythonNotebook环境/">pythonNotebook环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/15/pythonQt/">pythonQt</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/15/shadowsocks使用/">shadowsocks使用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/使用方法/">使用方法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术文章/">技术文章</a><span class="category-list-count">31</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/服务器/" style="font-size: 15px;">服务器</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/ShadowSocks/" style="font-size: 15px;">ShadowSocks</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Art/" style="font-size: 15px;">Art</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/内核/" style="font-size: 15px;">内核</a> <a href="/tags/内存/" style="font-size: 15px;">内存</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">董宇.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>